// hooks/useContract.ts
declare global {
  interface Window {
    ethereum?: any
  }
}

import { useState, useEffect } from 'react'
import { ethers } from 'ethers'
import { VOTING_ABI, VOTING_ADDRESS } from '../constants/contract'

export interface Proposal {
  id: number
  description: string
  voteCount: number
  endTime: number
  exists: boolean
  hasVoted?: boolean
}

export function useContract() {
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [loading, setLoading] = useState(false)
  const [contract, setContract] = useState<ethers.Contract | null>(null)
  const [signer, setSigner] = useState<ethers.Signer | null>(null)

  useEffect(() => {
    initializeContract()
  }, [])

  const initializeContract = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        const provider = new ethers.BrowserProvider(window.ethereum)
        const signer = await provider.getSigner()
        const contract = new ethers.Contract(VOTING_ADDRESS, VOTING_ABI, signer)
        
        setContract(contract)
        setSigner(signer)
        
        // Load proposals
        await loadProposals(contract, signer)
      } catch (error) {
        console.error('Failed to initialize contract:', error)
      }
    }
  }

  const loadProposals = async (contract: ethers.Contract, signer: ethers.Signer) => {
    try {
      setLoading(true)
      const count = await contract.proposalCount()
      const proposalsArray: Proposal[] = []
      
      for (let i = 1; i <= count; i++) {
        const proposal = await contract.proposals(i)
        const hasVoted = await contract.hasVoted(await signer.getAddress(), i)
        
        proposalsArray.push({
          id: i,
          description: proposal.description,
          voteCount: Number(proposal.voteCount),
          endTime: Number(proposal.endTime),
          exists: proposal.exists,
          hasVoted
        })
      }
      
      setProposals(proposalsArray)
    } catch (error) {
      console.error('Failed to load proposals:', error)
    } finally {
      setLoading(false)
    }
  }

  const createProposal = async (description: string, duration: number) => {
    if (!contract) return
    
    try {
      setLoading(true)
      const tx = await contract.createProposal(description, duration)
      await tx.wait()
      await loadProposals(contract, signer!)
    } catch (error) {
      console.error('Failed to create proposal:', error)
      throw error
    } finally {
      setLoading(false)
    }
  }

  const vote = async (proposalId: number) => {
    if (!contract) return
    
    try {
      setLoading(true)
      const tx = await contract.vote(proposalId)
      await tx.wait()
      await loadProposals(contract, signer!)
    } catch (error) {
      console.error('Failed to vote:', error)
      throw error
    } finally {
      setLoading(false)
    }
  }

  return {
    proposals,
    createProposal,
    vote,
    loading,
    connectWallet: initializeContract
  }
}
